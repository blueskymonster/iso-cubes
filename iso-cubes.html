<!DOCTYPE html>
<html>
<body style="background-color:black">

<canvas id="iso-cubes">Your browser does not support the canvas tag.</canvas>

<script>
var canvasElement = document.getElementById("iso-cubes");
const canvasSize = 1024;
canvasElement.width = `${canvasSize}`;
canvasElement.height = `${canvasSize}`;
const o = canvasElement.getContext("2d");
o.strokeStyle = 'black';
o.fillStyle = 'black';
o.lineWidth = 3.0;
const fillStyles = [];
const strokeStyles = [];
const pushStrokeStyle = (strokeStyle) => {
  strokeStyles.push(o.strokeStyle);
  o.strokeStyle = strokeStyle;
}
const popStrokeStyle = () => {
  const strokeStyle = strokeStyles.pop();
  o.strokeStyle = strokeStyle;
  return strokeStyle;
}
const pushFillStyle = (fillStyle) => {
  fillStyles.push(o.fillStyle);
  o.fillStyle = fillStyle;
}
const popFillStyle = () => {
  const fillStyle = fillStyles.pop();
  o.fillStyle = fillStyle;
  return fillStyle;
}
const rawDrawLine = (a, b) => {
  const [ax, ay] = a;
  const [bx, by] = b;
  o.beginPath();
  o.moveTo(ax, ay);
  o.lineTo(bx, by);
  o.stroke();
}
const drawBackground = () => {
  pushFillStyle("black");
  o.fillRect(0, 0, canvasSize, canvasSize);
  popFillStyle();
  pushStrokeStyle("green");
  const a = [0, 0];
  const b = [0, canvasSize];
  const c = [canvasSize, canvasSize];
  const d = [canvasSize, 0];
  rawDrawLine(a, b);
  rawDrawLine(b, c);
  rawDrawLine(c, d);
  rawDrawLine(d, a);
  popStrokeStyle();
};
const Vec = {
  plus: (a, b) => {
    const length = Math.max(a.length, b.length);
    const c = [];
    for (var i = 0; i < length; i++) {
      c.push((a[i] || 0) + (b[i] || 0));
    }
    return c;
  },
  scalarMul: (a, s) => a.map((ai) => ai * s),
}

  
// We can pass (x, y, z) coords to this function
// and we will automatically get the isometric 2D 
// projection because the Z coordinate is dropped.
const drawLine = (a, b) => {
  const offset = [canvasSize / 2, canvasSize/ 2];
  rawDrawLine(Vec.plus(a, offset), Vec.plus(b, offset));
}


const Cube = {
  /* Our cube datastructure is a list of 8 [x, y, z] points.
     The order of the points matters because they are used to
     determine between which points we should be drawing edges.
     All cubes should derived by rotating and scaling the unitCube.
  */
  unit: () => {
    return [
       [0, 0, 0],
       [0, 0, 1],
       [0, 1, 0],
       [0, 1, 1],
       [1, 0, 0],
       [1, 0, 1],
       [1, 1, 0],
       [1, 1, 1]
    ]
  },
  draw: (cube) => {
    const [a, b, c, d, e, f, g, h] = cube;
    drawLine(a, b);
    drawLine(b, d);
    drawLine(d, c);
    drawLine(c, a);
    drawLine(e, f);
    drawLine(f, h);
    drawLine(h, g);
    drawLine(g, e);
    drawLine(a, e);
    drawLine(c, g);
    drawLine(b, f);
    drawLine(d, h);
  },
  scale: (cube, scaleFactor) => cube.map((p) => Vec.scalarMul(p, scaleFactor)),
  translate: (cube, translation) => cube.map((p) => Vec.plus(p, translation)),
  cUnit: () => Cube.translate(Cube.unit(), [-0.5, -0.5, -0.5]),
  rotateX: (cube, theta) => {
    return cube.map((p) => {
      const [x, y, z] = p;
      return [
	x, 
	Math.cos(theta) * y - Math.sin(theta) * z,
	Math.sin(theta) * y + Math.cos(theta) * z
      ];
    });
  },
  rotateY: (cube, theta) => {
    return cube.map((p) => {
      const [x, y, z] = p;
      return [
	Math.cos(theta) * x + Math.sin(theta) * z, 
	y,
	Math.cos(theta) * z - Math.sin(theta) * x
      ]; 
    });
  },
  rotateZ: (cube, theta) => {
    return cube.map((p) => {
      const [x, y, z] = p;
      return [
	Math.cos(theta) * x - Math.sin(theta) * y, 
	Math.sin(theta) * x + Math.cos(theta) * y,
	z
      ];
    });
  },
  rotate: (cube, r) => {
   const [rx, ry, rz] = r;
   let rc = Cube.rotateX(cube, rx);
   rc = Cube.rotateY(rc, ry);
   return Cube.rotateZ(rc, rz);
  },
};

pushStrokeStyle("#FF0000");

let startTS, previousTS;
const animationSpeed = 8; // bigger is slower
let mainCubeRotation = [0, 0, 0];

const draw = (ts) => {
  if (startTS === undefined) {
    startTS = ts;
    previousTS = ts;
  }
  const totalElapsed = ts - startTS;
  const frameElapsed = ts - previousTS;

  if (previousTS !== ts) {
    o.clearRect(0, 0, canvasSize, canvasSize);
    drawBackground();
    const rSpeed = 0.005;
    mainCubeRotation = Vec.plus(
      mainCubeRotation, 
      [
        rSpeed * Math.sin(frameElapsed / 1000) * Math.PI * 2,
        rSpeed * Math.cos(frameElapsed / 1000) * Math.PI * 2,
        rSpeed * (Math.sin(frameElapsed / 1000) - Math.cos(frameElapsed / 1000)) * Math.PI * 2
      ]
    );
    const cube = Cube.scale(Cube.cUnit(), 100);
    const rotatedCube = Cube.rotate(cube, mainCubeRotation);
    Cube.draw(rotatedCube);
  }
  previousTS = ts;
  window.requestAnimationFrame(draw);
}
window.requestAnimationFrame(draw);

</script>

</body>
</html>

